项目名：market_conditions
需求：
# 重构当前整个市场行情获取模块

## 要求
- 重构当前整个市场行情获取模块，使其更加高效和可靠，不要有过度封装，注释要清晰，推荐使用websocket 推送方式，避免限频【ccxt pro】。
- 确保模块能够实时获取市场websocket支持的所有数据，包括OHLCV、ticker、orderbook、trades、funding_rate和mark_price，并且实时写入，每个币对单独的数据库文件。
- 模块应支持批量获取数据，以提高效率，获取的数据格式，要与 ccxt 同步 api 返回的响应体一致。
- 考虑添加错误处理机制，以处理网络连接问题、数据格式错误等异常情况。
- 考虑添加日志记录功能，以便于调试和监控。
- 考虑添加配置选项，以便于用户自定义模块行为，获取数据推送间隔，默认 ticker 配置0.5S一次【每种数据类型不同间隔，可配置，如未提及，可根据你的经验帮我设置默认间隔】，支持币对配置【具体币对】，支持数据获取配置，支持交易所配置，默认为 Bybit 合约。
- 落库数据时间与返回时间要一致，不能有时间差，使用ms级时间戳。
- 写入数据要考虑高可用，不能因为写入失败而导致数据丢失。
- 获取K线数据时，如数据量不满足，则使用 ccxt 同步接口获取满足数据，并将其写入数据库，已便于下次使用。
- 数据库清除旧数据，只保留最近 7 天的数据即可，每次写入时检查并清理。
- 模块与模块之间要独立，互不干扰，共享配置。
- 目录设计要简洁，一目了然，不要有任何多余的文件。
- 外部接口 ：重构后的模块要支持其他部分调用，提供同步的数据获取方式，越易用越好，越符合 ccxt 同步 api 调用习惯越好，最好是封装成一个模块，提供简单的方法调用，只要有其他模块需要调用，就可以直接导入这个模块，只要有其他模块导入，就自动执行数据获取模块。
- 自动执行控制 ：当有多个模块导入时，需要避免重复启动数据获取模块，只启动一次。
- 当所有导入模块都退出时，数据获取模块是否应该自动停止并释放资源，以避免资源浪费。
- 配置文件格式 ：配置使用YAML格式
- 日志文件大小限制 10M ，超过10M ，则自动备份并保留最近5个备份，每个备份文件大小为10M。
- 写入机制 ：根据当前的需求，以及数据获取机制，读取机制，请你来帮我设计合理的方案。
- 在当前目录下重新建立新的目录重构～！！！！
- 关于数据获取，可以参考get_market.py脚本【仅参考】
- 使用uv管理依赖以及虚拟环境【请严格按照uv规范进行操作】。

# 验收标准
### Case
- 创建example.py脚本，导入数据获取模块，调用数据获取模块的方法，获取数据并打印。
- 例：
```python
# 以下仅为示例，实际效果应该如同调用ccxt同步接口
import market_data_collector

with market_data_collector.MarketDataReader() as reader:
    # 获取OHLCV数据，返回与ccxt.fetchOHLCV完全一致的格式
    ohlcv = reader.get_ohlcv_data('XRP/USDT:USDT', '15m', 200)
    print(f"获取到 {len(ohlcv)} 条OHLCV数据")
    if ohlcv:
        print(f"最新一条数据: {ohlcv[-1]}")

    # 获取ticker数据
    ticker = reader.get_ticker_data('XRP/USDT:USDT') 
    print(f"Ticker数据: {ticker}")

    # 获取orderbook数据
    orderbook = reader.get_orderbook_data('XRP/USDT:USDT', 10)
    print(f"Orderbook数据: {orderbook}")

    # 获取trades数据
    trades = reader.get_trades_data('XRP/USDT:USDT', limit=10)
    print(f"获取到 {len(trades)} 条trades数据")

    # 获取funding_rate数据
    funding_rate = reader.get_funding_rate_data('XRP/USDT:USDT')
    print(f"Funding Rate数据: {funding_rate}")

    # 获取mark_price数据
    mark_price = reader.get_mark_price_data('XRP/USDT:USDT')
    print(f"Mark Price数据: {mark_price}")
```
- 确保模块能够实时获取市场websocket支持的所有数据，包括OHLCV、ticker、orderbook、trades、funding_rate和mark_price，并且实时写入，每个币对单独的数据库文件。
- 确保模块能够批量获取数据，以提高效率，获取的数据格式，要与 ccxt 同步 api 返回的响应体一致。


get_market.py
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Bybit合约市场数据WebSocket接收脚本
使用CCXT Pro库接收Bybit合约的实时市场数据
"""

import asyncio
import json
import sys
import os
from datetime import datetime
import time

# 添加项目根目录到路径
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# 导入CCXT Pro
import ccxt.pro as ccxtpro

# 导入数据库操作模块
from market_data_db import MarketDataDB

# 全局配置参数
DATA_FETCH_INTERVAL = 0.5  # 默认数据获取间隔，单位：秒（默认500毫秒）
FUNDING_RATE_INTERVAL = 600  # 资金费率获取间隔，单位：秒（默认10分钟）


class BybitMarketData:
    """Bybit合约市场数据接收类"""
    
    def __init__(self, api_key=None, secret=None, sandbox=False):
        """
        初始化Bybit市场数据接收器
        
        参数:
        api_key - API密钥(可选，对于公开市场数据不需要)
        secret - API密钥(可选，对于公开市场数据不需要)
        sandbox - 是否使用测试环境
        """
        self.exchange = ccxtpro.bybit({
            'apiKey': api_key or '',
            'secret': secret or '',
            'sandbox': sandbox,
            'options': {
                'defaultType': 'swap',  # 设置为合约交易
            },
        })
        
        # 初始化数据库操作模块
        self.db = MarketDataDB()
        
        # 存储订阅的数据
        self.tickers = {}
        self.orderbooks = {}
        self.trades = {}
        self.ohlcv = {}
        self.funding_rates = {}
        self.mark_prices = {}
        
        # 订阅的交易对列表
        self.symbols = [
            'BTC/USDT:USDT',
            'ETH/USDT:USDT',
            'SOL/USDT:USDT',
            'XRP/USDT:USDT'
        ]
        
        # 运行状态
        self.running = False
        
    async def start(self):
        """启动市场数据接收"""
        self.running = True
        print("启动Bybit合约市场数据接收...")
        
        # 初始化所有币种的数据库
        print("初始化数据库...")
        for symbol in self.symbols:
            self.db.init_symbol_db(symbol)
        print("数据库初始化完成")
        
        # 创建订阅任务
        tasks = []
        
        # 订阅ticker数据
        for symbol in self.symbols:
            tasks.append(self.watch_ticker(symbol))
        
        # 订阅orderbook数据
        for symbol in self.symbols:
            tasks.append(self.watch_orderbook(symbol))
        
        # 订阅trades数据
        for symbol in self.symbols:
            tasks.append(self.watch_trades(symbol))
        
        # 订阅OHLCV数据(K线)
        for symbol in self.symbols:
            tasks.append(self.watch_ohlcv(symbol, '1m'))
            tasks.append(self.watch_ohlcv(symbol, '5m'))
            tasks.append(self.watch_ohlcv(symbol, '15m'))
        
        # 订阅资金费率
        for symbol in self.symbols:
            tasks.append(self.watch_funding_rate(symbol))
        
        # 订阅标记价格
        for symbol in self.symbols:
            tasks.append(self.watch_mark_price(symbol))
        
        # 等待所有任务完成
        try:
            await asyncio.gather(*tasks)
        except KeyboardInterrupt:
            print("接收到中断信号，正在停止...")
            await self.stop()
        except Exception as e:
            print(f"发生错误: {e}")
            await self.stop()
    
    async def stop(self):
        """停止市场数据接收"""
        self.running = False
        print("正在关闭连接...")
        await self.exchange.close()
        print("连接已关闭")
    
    async def watch_ticker(self, symbol):
        """监视ticker数据"""
        print(f"订阅 {symbol} 的ticker数据...")
        while self.running:
            try:
                ticker = await self.exchange.watch_ticker(symbol)
                self.tickers[symbol] = ticker
                
                # 存储到数据库
                try:
                    self.db.insert_ticker(symbol, ticker)
                except Exception as db_error:
                    print(f"存储 {symbol} ticker数据到数据库时出错: {db_error}")
                
                timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                print(f"[{timestamp}] {symbol} Ticker: "
                      f"Last: {ticker['last']}, "
                      f"Change: {ticker['change']}, "
                      f"Percentage: {ticker['percentage']}, "
                      f"Volume: {ticker['baseVolume']}")
                
                # 控制获取频率
                await asyncio.sleep(DATA_FETCH_INTERVAL)
            except Exception as e:
                print(f"获取 {symbol} ticker数据时出错: {e}")
                await asyncio.sleep(DATA_FETCH_INTERVAL)
    
    async def watch_orderbook(self, symbol):
        """监视orderbook数据"""
        print(f"订阅 {symbol} 的orderbook数据...")
        while self.running:
            try:
                # 使用Bybit支持的深度限制值：1, 50, 200, 500
                orderbook = await self.exchange.watch_order_book(symbol, 50)
                self.orderbooks[symbol] = orderbook
                
                # 存储到数据库
                try:
                    self.db.insert_orderbook(symbol, orderbook)
                except Exception as db_error:
                    print(f"存储 {symbol} orderbook数据到数据库时出错: {db_error}")
                
                timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                best_bid = orderbook['bids'][0] if orderbook['bids'] else None
                best_ask = orderbook['asks'][0] if orderbook['asks'] else None
                
                if best_bid and best_ask:
                    spread = float(best_ask[0]) - float(best_bid[0])
                    spread_percent = (spread / float(best_bid[0])) * 100
                    print(f"[{timestamp}] {symbol} OrderBook: "
                          f"BestBid: {best_bid[0]}({best_bid[1]}), "
                          f"BestAsk: {best_ask[0]}({best_ask[1]}), "
                          f"Spread: {spread:.4f}({spread_percent:.4f}%)")
                
                # 控制获取频率
                await asyncio.sleep(DATA_FETCH_INTERVAL)
            except Exception as e:
                print(f"获取 {symbol} orderbook数据时出错: {e}")
                await asyncio.sleep(DATA_FETCH_INTERVAL)
    
    async def watch_trades(self, symbol):
        """监视trades数据"""
        print(f"订阅 {symbol} 的trades数据...")
        while self.running:
            try:
                trades = await self.exchange.watch_trades(symbol)
                self.trades[symbol] = trades
                
                # 存储到数据库
                try:
                    self.db.insert_trades(symbol, trades)
                except Exception as db_error:
                    print(f"存储 {symbol} trades数据到数据库时出错: {db_error}")
                
                timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                
                # 只打印最新的交易
                if trades:
                    latest_trade = trades[0]
                    print(f"[{timestamp}] {symbol} Trade: "
                          f"Price: {latest_trade['price']}, "
                          f"Amount: {latest_trade['amount']}, "
                          f"Side: {latest_trade['side']}")
                
                # 控制获取频率
                await asyncio.sleep(DATA_FETCH_INTERVAL)
            except Exception as e:
                print(f"获取 {symbol} trades数据时出错: {e}")
                await asyncio.sleep(DATA_FETCH_INTERVAL)
    
    async def watch_ohlcv(self, symbol, timeframe):
        """监视OHLCV数据(K线)"""
        print(f"订阅 {symbol} 的{timeframe} K线数据...")
        while self.running:
            try:
                ohlcv = await self.exchange.watch_ohlcv(symbol, timeframe)
                key = f"{symbol}_{timeframe}"
                self.ohlcv[key] = ohlcv
                
                # 存储到数据库
                try:
                    self.db.insert_ohlcv(symbol, timeframe, ohlcv)
                    # print(f"成功存储 {symbol} {timeframe} {ohlcv} OHLCV数据到数据库")
                except Exception as db_error:
                    print(f"存储 {symbol} {timeframe} OHLCV数据到数据库时出错: {db_error}")
                
                if ohlcv:
                    latest_candle = ohlcv[-1]  # 最新的K线
                    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    print(f"[{timestamp}] {symbol} {timeframe} OHLCV: "
                          f"O: {latest_candle[1]}, H: {latest_candle[2]}, "
                          f"L: {latest_candle[3]}, C: {latest_candle[4]}, "
                          f"V: {latest_candle[5]}")
                
                # 控制获取频率
                await asyncio.sleep(DATA_FETCH_INTERVAL)
            except Exception as e:
                print(f"获取 {symbol} {timeframe} OHLCV数据时出错: {e}")
                await asyncio.sleep(DATA_FETCH_INTERVAL)
    
    async def watch_funding_rate(self, symbol):
        """监视资金费率数据"""
        print(f"订阅 {symbol} 的资金费率数据...")
        while self.running:
            try:
                # 使用CCXT的fetchFundingRate方法获取资金费率
                funding_rate = await self.exchange.fetch_funding_rate(symbol)
                self.funding_rates[symbol] = funding_rate
                
                # 存储到数据库
                try:
                    self.db.insert_funding_rate(symbol, funding_rate)
                except Exception as db_error:
                    print(f"存储 {symbol} 资金费率数据到数据库时出错: {db_error}")
                
                timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                print(f"[{timestamp}] {symbol} FundingRate: "
                      f"Rate: {funding_rate['fundingRate']}, "
                      f"NextFundingTime: {funding_rate['fundingTimestamp']}")
                
                # 使用专门的资金费率获取间隔
                await asyncio.sleep(FUNDING_RATE_INTERVAL)
            except Exception as e:
                print(f"获取 {symbol} 资金费率数据时出错: {e}")
                await asyncio.sleep(60)  # 出错时等待1分钟再重试
    
    async def watch_mark_price(self, symbol):
        """监视标记价格数据"""
        print(f"订阅 {symbol} 的标记价格数据...")
        while self.running:
            try:
                # 使用ticker数据中的标记价格信息
                ticker = await self.exchange.watch_ticker(symbol)
                
                # 检查ticker中是否包含标记价格信息
                if 'markPrice' in ticker:
                    mark_price = ticker['markPrice']
                elif 'info' in ticker and 'markPrice' in ticker['info']:
                    mark_price = ticker['info']['markPrice']
                else:
                    # 如果没有标记价格，使用最新价格作为替代
                    mark_price = ticker['last']
                
                mark_price_data = {'markPrice': mark_price}
                self.mark_prices[symbol] = mark_price_data
                
                # 存储到数据库
                try:
                    self.db.insert_mark_price(symbol, mark_price_data)
                except Exception as db_error:
                    print(f"存储 {symbol} 标记价格数据到数据库时出错: {db_error}")
                
                timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                print(f"[{timestamp}] {symbol} MarkPrice: {mark_price}")
                
                # 控制获取频率
                await asyncio.sleep(DATA_FETCH_INTERVAL)
            except Exception as e:
                print(f"获取 {symbol} 标记价格数据时出错: {e}")
                await asyncio.sleep(DATA_FETCH_INTERVAL)
    
    def save_data_to_file(self, filename="market_data.json"):
        """保存数据到文件"""
        data = {
            'timestamp': datetime.now().isoformat(),
            'tickers': self.tickers,
            'orderbooks': self.orderbooks,
            'trades': self.trades,
            'ohlcv': self.ohlcv,
            'funding_rates': self.funding_rates,
            'mark_prices': self.mark_prices,
        }
        
        with open(filename, 'w') as f:
            json.dump(data, f, indent=2)
        
        print(f"数据已保存到 {filename}")


async def main():
    """主函数"""
    # 创建市场数据接收器实例
    # 注意：对于公开市场数据，不需要API密钥
    market_data = BybitMarketData()
    
    try:
        # 启动市场数据接收
        await market_data.start()
    except KeyboardInterrupt:
        print("接收到中断信号，正在停止...")
        await market_data.stop()


if __name__ == "__main__":
    # 运行主函数
    asyncio.run(main())
```